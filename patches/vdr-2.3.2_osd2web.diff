--- ../vdr-2.3.2.plain//./osd.c	2015-09-10 16:12:06.000000000 +0200
+++ ./osd.c	2017-03-10 10:46:11.152029953 +0100
@@ -2000,6 +2000,7 @@
 double cOsdProvider::oldAspect = 1.0;
 cImage *cOsdProvider::images[MAXOSDIMAGES] = { NULL };
 int cOsdProvider::osdState = 0;
+bool cOsdProvider::triggerRecalcAndRefresh = false;

 cOsdProvider::cOsdProvider(void)
 {
@@ -2067,6 +2068,13 @@
   return Result;
 }

+bool cOsdProvider::GetTriggerRecalcAndRefresh()
+{
+   bool trg = triggerRecalcAndRefresh;
+   triggerRecalcAndRefresh = false;
+   return trg;
+}
+
 bool cOsdProvider::SupportsTrueColor(void)
 {
   if (osdProvider) {
--- ../vdr-2.3.2.plain/vdr.c    2016-12-23 15:34:37.000000000 +0100
+++ vdr.c       2017-03-10 11:35:06.018052006 +0100
@@ -983,6 +983,8 @@
           if (Now != lastOsdSizeUpdate) { // once per second
              cOsdProvider::UpdateOsdSize();
              lastOsdSizeUpdate = Now;
+             if (cOsdProvider::GetTriggerRecalcAndRefresh() && Menu)
+                ((cOsdMenu*)Menu)->Display();
              }
         }
         // Restart the Watchdog timer:
--- ../vdr-2.3.2.plain//./osd.h	2015-04-19 14:18:25.000000000 +0200
+++ ./osd.h	2017-03-10 10:47:06.240286958 +0100
@@ -965,6 +965,7 @@
   static double oldAspect;
   static cImage *images[MAXOSDIMAGES];
   static int osdState;
+  static bool triggerRecalcAndRefresh;
 protected:
   virtual cOsd *CreateOsd(int Left, int Top, uint Level) = 0;
       ///< Returns a pointer to a newly created cOsd object, which will be located
@@ -1007,6 +1008,10 @@
       ///< and is compared against State when calling the method.
       ///< OsdSizeChanged() can be called with an uninitialized State to just get
       ///< the current value of State.
+  static void TriggerRecalcAndRefresh() { triggerRecalcAndRefresh = true; }
+      ///< force call UpdateOsdSize(true) and redisplay of open OSD menu
+  static bool GetTriggerRecalcAndRefresh();
+      ///< get and restet trigger state
   static bool SupportsTrueColor(void);
       ///< Returns true if the current OSD provider is able to handle a true color OSD.
   static int StoreImage(const cImage &Image);
